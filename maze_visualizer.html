<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Maze Predictions Visualizer</title>
  <style>
    body { font-family: sans-serif; margin: 16px; }
    .controls { margin-bottom: 12px; }
    .grid-canvas { border: 1px solid #333; margin-top: 8px; }
    #status { margin-top: 8px; }
    button { padding: 8px 12px; margin-right: 8px; }
  </style>
</head>
<body>
  <h1>Maze Predictions Visualizer</h1>
  <div class="controls">
    <button id="loadPreds">Load Server Prediction</button>
    <label for="predictUrl"> Predict URL:</label>
    <input id="predictUrl" type="text" value="https://alphaxiv--tinyrecursive-eval-predict-dev.modal.run/" style="width:420px" />
    <label for="exampleIndex">Example index:</label>
    <input id="exampleIndex" type="number" value="0" min="0" style="width:60px" />
    <label for="predFile">Preds file (optional):</label>
    <input id="predFile" type="text" placeholder="step_32550_all_preds.0" style="width:220px" />
    <button id="loadExample">Load Example (from uploaded .npy)</button>
  </div>

  <div id="status">Status: idle</div>
  <div id="canvasHolder"></div>

  <script>
  // Render a 2D grid to a canvas. grid is a 2D array of numbers.
  function renderGridToCanvas(grid, scale=10) {
    const rows = grid.length;
    const cols = grid[0].length;
    const canvas = document.createElement('canvas');
    canvas.width = cols * scale;
    canvas.height = rows * scale;
    canvas.className = 'grid-canvas';
    const ctx = canvas.getContext('2d');

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const v = grid[r][c];
        ctx.fillStyle = valueToColor(v);
        ctx.fillRect(c*scale, r*scale, scale, scale);
      }
    }
    return canvas;
  }

  function valueToColor(v) {
    // Generic palette for integer-labeled maze grids. The model outputs
    // integer labels per cell; we map common values to intuitive colors.
    // You can customize these if your dataset uses different encodings.
    const palette = {
      0: '#FFFFFF', // empty / pad
      1: '#000000', // wall
      2: '#EEEEEE', // open / floor
      3: '#00AA00', // goal
      4: '#FFFF00', // special marker (yellow)
      5: '#1E90FF', // path / predicted fill (blue)
      6: '#FF00FF', // extra
    };
    return palette.hasOwnProperty(v) ? palette[v] : '#CCCCCC';
  }

  async function loadServerPrediction() {
    // No fallbacks: call the exact predict URL provided by the user and require a 'solved_maze' key.
    const PREDICT_URL = document.getElementById('predictUrl').value.trim();
    const idx = parseInt(document.getElementById('exampleIndex').value, 10);
    const file = (document.getElementById('predFile')?.value || '').trim();
    try {
      if (!Number.isInteger(idx) || idx < 0) throw new Error('Example index must be a non-negative integer');
      // Ensure the URL is absolute and non-empty
      if (!PREDICT_URL) throw new Error('Predict URL is empty');
      const url = new URL(PREDICT_URL);
      url.searchParams.set('index', String(idx));
      if (file) url.searchParams.set('file', file);

      document.getElementById('status').textContent = 'Status: fetching prediction from ' + url.toString() + ' ...';
      const resp = await fetch(url.toString(), { method: 'GET' });
      if (!resp.ok) {
        throw new Error('Server returned HTTP ' + resp.status);
      }
      const data = await resp.json();

      // Strict: must contain 'solved_maze' as a 2D array.
      if (!data || !('solved_maze' in data)) {
        throw new Error("Response JSON missing required 'solved_maze' field");
      }

      let grid = data.solved_maze;

      // If grid is a flat 1D array -> try to reshape into square
      if (!Array.isArray(grid[0])) {
        const flat = grid;
        const L = flat.length;
        const side = Math.round(Math.sqrt(L));
        const newGrid = [];
        for (let r = 0; r < side; r++) {
          newGrid.push(flat.slice(r*side, (r+1)*side));
        }
        grid = newGrid;
      }

      const holder = document.getElementById('canvasHolder');
      holder.innerHTML = '';

      // Make the canvas scale adaptively so large grids still fit the view.
      const side = grid.length;
      const maxPixels = Math.min(window.innerWidth - 40, 900);
      const scale = Math.max(4, Math.floor(maxPixels / side));

      holder.appendChild(renderGridToCanvas(grid, scale));
      const retIdx = Number.isInteger(data.index) ? data.index : idx;
      document.getElementById('status').textContent = 'Status: rendered prediction (index: ' + retIdx + ', source: ' + (data.source_file || 'unknown') + ')';

      renderLegend();
    } catch (err) {
      // Per request: no fallbacks, surface the error to the user.
      document.getElementById('status').textContent = 'Status: error - ' + err.message;
      console.error(err);
    }
  }

  function renderLegend() {
    const legendId = 'vizLegend';
    let legend = document.getElementById(legendId);
    if (!legend) {
      legend = document.createElement('div');
      legend.id = legendId;
      legend.style.marginTop = '8px';
      document.getElementById('canvasHolder').appendChild(legend);
    }
    const items = [
      {k:1, label:'Wall'},
      {k:2, label:'Open'},
      {k:5, label:'Predicted / path'},
      {k:3, label:'Goal'},
      {k:4, label:'Marker'}
    ];
    legend.innerHTML = '<strong>Legend:</strong> ' + items.map(it => {
      const color = valueToColor(it.k);
      return `<span style="display:inline-block;margin-right:10px"><span style="display:inline-block;width:16px;height:16px;background:${color};border:1px solid #000;margin-right:6px"></span>${it.label}</span>`;
    }).join('');
  }

  document.getElementById('loadPreds').addEventListener('click', loadServerPrediction);

  // For future: support loading local examples (not required now). Hook placeholder.
  document.getElementById('loadExample').addEventListener('click', ()=>{
    alert('Local example load not implemented in this minimal maze visualizer. Use "Load Server Prediction" for now.');
  });

  </script>
</body>
</html>
