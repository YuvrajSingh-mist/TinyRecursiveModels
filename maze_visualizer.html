<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Maze Predictions Visualizer</title>
  <style>
    body { font-family: sans-serif; margin: 16px; }
    .controls { margin-bottom: 12px; }
    .grid-canvas { border: 1px solid #333; margin-top: 8px; }
    #status { margin-top: 8px; }
    button { padding: 8px 12px; margin-right: 8px; }
  </style>
</head>
<body>
  <h1>Maze Predictions Visualizer</h1>
  <div class="controls">
    <button id="loadPreds">Load Server Prediction</button>
    <label for="predictUrl"> Predict URL:</label>
    <input id="predictUrl" type="text" value="https://alphaxiv--tinyrecursive-eval-predict-dev.modal.run/" style="width:420px" />
    <label for="exampleIndex">Example index:</label>
    <input id="exampleIndex" type="number" value="0" min="0" style="width:60px" />
    <label for="predFile">Preds file (optional):</label>
    <input id="predFile" type="text" placeholder="step_32550_all_preds.0" style="width:220px" />
    <button id="loadExample">Load Example (from uploaded .npy)</button>
    <div style="margin-top:10px"></div>
    <label>Paste input grid JSON (2D or flat):</label>
    <textarea id="inputGridJson" rows="4" cols="60" placeholder="[[1,0,...], [0,1,...], ...]"></textarea>
    <button id="sendInput">Predict from pasted grid (POST)</button>
  </div>

  <div id="status">Status: idle</div>
  <div id="canvasHolder"></div>

  <script>
  // Render a 2D grid to a canvas. grid is a 2D array of numbers.
  function renderGridToCanvas(grid, scale=10) {
    const rows = grid.length;
    const cols = grid[0].length;
    const canvas = document.createElement('canvas');
    canvas.width = cols * scale;
    canvas.height = rows * scale;
    canvas.className = 'grid-canvas';
    const ctx = canvas.getContext('2d');

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const v = grid[r][c];
        ctx.fillStyle = valueToColor(v);
        ctx.fillRect(c*scale, r*scale, scale, scale);
      }
    }
    return canvas;
  }

  function valueToColor(v) {
    // Generic palette for integer-labeled maze grids. The model outputs
    // integer labels per cell; we map common values to intuitive colors.
    // You can customize these if your dataset uses different encodings.
    const palette = {
      0: '#FFFFFF', // empty / pad
      1: '#000000', // wall
      2: '#EEEEEE', // open / floor
      3: '#00AA00', // goal
      4: '#FFFF00', // special marker (yellow)
      5: '#1E90FF', // path / predicted fill (blue)
      6: '#FF00FF', // extra
    };
    return palette.hasOwnProperty(v) ? palette[v] : '#CCCCCC';
  }

  async function loadServerPrediction() {
    // No fallbacks: call the exact predict URL provided by the user and require a 'solved_maze' key.
    const PREDICT_URL = document.getElementById('predictUrl').value.trim();
    const idx = parseInt(document.getElementById('exampleIndex').value, 10);
    const file = (document.getElementById('predFile')?.value || '').trim();
    try {
      if (!Number.isInteger(idx) || idx < 0) throw new Error('Example index must be a non-negative integer');
      // Ensure the URL is absolute and non-empty
      if (!PREDICT_URL) throw new Error('Predict URL is empty');
      const url = new URL(PREDICT_URL);
      url.searchParams.set('index', String(idx));
      if (file) url.searchParams.set('file', file);

      document.getElementById('status').textContent = 'Status: fetching prediction from ' + url.toString() + ' ...';
      const resp = await fetch(url.toString(), { method: 'GET' });
      if (!resp.ok) {
        throw new Error('Server returned HTTP ' + resp.status);
      }
      const data = await resp.json();

      // Strict: must contain 'solved_maze' as a 2D square array.
      if (!data || !('solved_maze' in data)) {
        throw new Error("Response JSON missing required 'solved_maze' field");
      }

      let grid = data.solved_maze;

      // Normalize predicted grid to 2D and validate square
      if (!Array.isArray(grid) || grid.length === 0) {
        throw new Error('Predicted grid is empty or invalid');
      }
      if (!Array.isArray(grid[0])) {
        const flat = grid;
        const L = flat.length;
        const side = Math.sqrt(L);
        if (!Number.isInteger(side)) {
          throw new Error(`Predicted grid length ${L} is not a perfect square`);
        }
        const newGrid = [];
        for (let r = 0; r < side; r++) {
          newGrid.push(flat.slice(r*side, (r+1)*side));
        }
        grid = newGrid;
      }
      const hPred = grid.length;
      const wPred = Array.isArray(grid[0]) ? grid[0].length : 0;
      if (hPred !== wPred) {
        throw new Error(`Predicted grid is not square: ${hPred}x${wPred}`);
      }

      const holder = document.getElementById('canvasHolder');
      holder.innerHTML = '';

      // Make the canvas scale adaptively so large grids still fit the view.
      const side = grid.length;
      const maxPixels = Math.min(window.innerWidth - 40, 900);
      const scale = Math.max(4, Math.floor(maxPixels / side));

      // Side-by-side layout
  const wrap = document.createElement('div');
  wrap.style.display = 'grid';
  wrap.style.gridTemplateColumns = '1fr 1fr 1fr';
  wrap.style.gap = '16px';

  const left = document.createElement('div');
  const right = document.createElement('div');
  const extra = document.createElement('div');

  const headerIn = document.createElement('div');
  headerIn.textContent = 'Input grid';
  headerIn.style.fontWeight = 'bold';
  headerIn.style.marginBottom = '4px';
  left.appendChild(headerIn);
      const inputGrid = data.input_maze;
      if (!Array.isArray(inputGrid) || inputGrid.length === 0) {
        throw new Error('Input grid unavailable in server response');
      }
      if (!Array.isArray(inputGrid[0])) {
        const flat = inputGrid;
        const L = flat.length;
        const side = Math.sqrt(L);
        if (!Number.isInteger(side)) {
          throw new Error(`Input grid length ${L} is not a perfect square`);
        }
        const newGrid = [];
        for (let r = 0; r < side; r++) {
          newGrid.push(flat.slice(r*side, (r+1)*side));
        }
        inputGrid.length = 0; // replace contents
        for (const row of newGrid) inputGrid.push(row);
      }
      const hIn = inputGrid.length;
      const wIn = Array.isArray(inputGrid[0]) ? inputGrid[0].length : 0;
      if (hIn !== wIn) {
        throw new Error(`Input grid is not square: ${hIn}x${wIn}`);
      }
      const inScale = Math.max(4, Math.floor(maxPixels / hIn));
      left.appendChild(renderGridToCanvas(inputGrid, inScale));

  const headerOut = document.createElement('div');
  headerOut.textContent = 'Predicted grid';
  headerOut.style.fontWeight = 'bold';
  headerOut.style.marginBottom = '4px';
  right.appendChild(headerOut);
      right.appendChild(renderGridToCanvas(grid, scale));

      // Optional: ground truth labels if server returned target_maze
      if (data.target_maze) {
        const gtHeader = document.createElement('div');
        gtHeader.textContent = 'Ground truth';
        gtHeader.style.fontWeight = 'bold';
        gtHeader.style.marginTop = '16px';
        extra.appendChild(gtHeader);
        let gt = data.target_maze;
        if (!Array.isArray(gt[0])) {
          const flat = gt;
          const L = flat.length;
          const side = Math.sqrt(L);
          if (Number.isInteger(side)) {
            const newGrid = [];
            for (let r = 0; r < side; r++) newGrid.push(flat.slice(r*side, (r+1)*side));
            gt = newGrid;
          }
        }
        const gtScale = Math.max(4, Math.floor(maxPixels / gt.length));
        extra.appendChild(renderGridToCanvas(gt, gtScale));
      }

  wrap.appendChild(left);
  wrap.appendChild(right);
  if (extra.childNodes.length > 0) wrap.appendChild(extra);
      holder.appendChild(wrap);
      const retIdx = Number.isInteger(data.index) ? data.index : idx;
      document.getElementById('status').textContent = 'Status: rendered (index: ' + retIdx + ', source: ' + (data.source_file || 'unknown') + ')';

      renderLegend();
    } catch (err) {
      // Per request: no fallbacks, surface the error to the user.
      document.getElementById('status').textContent = 'Status: error - ' + err.message;
      console.error(err);
    }
  }

  function renderLegend() {
    const legendId = 'vizLegend';
    let legend = document.getElementById(legendId);
    if (!legend) {
      legend = document.createElement('div');
      legend.id = legendId;
      legend.style.marginTop = '8px';
      document.getElementById('canvasHolder').appendChild(legend);
    }
    const items = [
      {k:1, label:'Wall'},
      {k:2, label:'Open'},
      {k:5, label:'Predicted / path'},
      {k:3, label:'Goal'},
      {k:4, label:'Marker'}
    ];
    legend.innerHTML = '<strong>Legend:</strong> ' + items.map(it => {
      const color = valueToColor(it.k);
      return `<span style="display:inline-block;margin-right:10px"><span style="display:inline-block;width:16px;height:16px;background:${color};border:1px solid #000;margin-right:6px"></span>${it.label}</span>`;
    }).join('');
  }

  document.getElementById('loadPreds').addEventListener('click', loadServerPrediction);

  async function postInputGrid() {
    const PREDICT_URL = document.getElementById('predictUrl').value.trim();
    const raw = document.getElementById('inputGridJson').value.trim();
    try {
      if (!PREDICT_URL) throw new Error('Predict URL is empty');
      if (!raw) throw new Error('Paste an input grid JSON');
      const body = { grid: JSON.parse(raw), task: 'maze' };
      const resp = await fetch(PREDICT_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!resp.ok) throw new Error('Server returned HTTP ' + resp.status);
      const data = await resp.json();
      // Reuse render path: pretend this is what GET returned
      if (!data || !('solved_maze' in data)) throw new Error("Response JSON missing 'solved_maze'");
      // Minimal reuse: set status and let user click Load Server Prediction to compare
      document.getElementById('status').textContent = 'Status: POST prediction ok. Rendering...';
      // Build a fake URL-less render path: just draw input and prediction
      const holder = document.getElementById('canvasHolder');
      holder.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.style.display = 'grid';
      wrap.style.gridTemplateColumns = '1fr 1fr 1fr';
      wrap.style.gap = '16px';
      const left = document.createElement('div');
      const right = document.createElement('div');
      const extra = document.createElement('div');
      const maxPixels = Math.min(window.innerWidth - 40, 900);
      const inp = Array.isArray(data.input_maze) ? data.input_maze : body.grid;
      if (!Array.isArray(inp[0])) {
        const L = inp.length; const s = Math.sqrt(L); if (!Number.isInteger(s)) throw new Error('Input not square');
        const g=[]; for (let r=0;r<s;r++) g.push(inp.slice(r*s,(r+1)*s));
        data.input_maze = g;
      }
      const inScale = Math.max(4, Math.floor(maxPixels / data.input_maze.length));
      const headerIn = document.createElement('div'); headerIn.textContent = 'Input grid'; headerIn.style.fontWeight='bold'; headerIn.style.marginBottom='4px'; left.appendChild(headerIn);
      left.appendChild(renderGridToCanvas(data.input_maze, inScale));
      let pred = data.solved_maze; if (!Array.isArray(pred[0])) { const L=pred.length; const s=Math.sqrt(L); if(!Number.isInteger(s)) throw new Error('Pred not square'); const g=[]; for(let r=0;r<s;r++) g.push(pred.slice(r*s,(r+1)*s)); pred=g; }
      const scale = Math.max(4, Math.floor(maxPixels / pred.length));
      const headerOut = document.createElement('div'); headerOut.textContent='Predicted grid'; headerOut.style.fontWeight='bold'; headerOut.style.marginBottom='4px'; right.appendChild(headerOut);
      right.appendChild(renderGridToCanvas(pred, scale));
      if (data.target_maze) { let gt=data.target_maze; if(!Array.isArray(gt[0])){ const L=gt.length; const s=Math.sqrt(L); if(Number.isInteger(s)){ const g=[]; for(let r=0;r<s;r++) g.push(gt.slice(r*s,(r+1)*s)); gt=g; }} const gtScale=Math.max(4, Math.floor(maxPixels/gt.length)); const gtHeader=document.createElement('div'); gtHeader.textContent='Ground truth'; gtHeader.style.fontWeight='bold'; gtHeader.style.marginTop='16px'; extra.appendChild(gtHeader); extra.appendChild(renderGridToCanvas(gt, gtScale)); }
      wrap.appendChild(left); wrap.appendChild(right); if (extra.childNodes.length>0) wrap.appendChild(extra); holder.appendChild(wrap);
      renderLegend();
    } catch (err) {
      document.getElementById('status').textContent = 'Status: error - ' + err.message;
      console.error(err);
    }
  }

  document.getElementById('sendInput').addEventListener('click', postInputGrid);

  // For future: support loading local examples (not required now). Hook placeholder.
  document.getElementById('loadExample').addEventListener('click', ()=>{
    alert('Local example load not implemented in this minimal maze visualizer. Use "Load Server Prediction" for now.');
  });

  </script>
</body>
</html>
